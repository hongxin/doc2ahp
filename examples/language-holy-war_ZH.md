# 示例：高并发交易系统编程语言选型

[English](language-holy-war.md)

> 场景：一家金融科技初创公司正在构建实时交易引擎。当前 Python 原型能处理 100 TPS，但需要扩展到 10,000+ TPS 并实现亚毫秒级 P99 延迟。6 人团队背景各异（2 名 Python、2 名 Java、1 名 Go、1 名 C++）。重写预算：4 个月。

## Step 1: 决策框架构建

**决策目标**：为重写高频交易引擎选择最佳编程语言，满足极端延迟和吞吐量要求

**评估层次**：

```
选择交易引擎最佳语言
├── 性能
│   ├── 原始吞吐量（TPS 上限）
│   ├── 延迟可预测性（GC 停顿、尾延迟）
│   └── 内存效率
├── 开发速度
│   ├── 学习曲线（团队达到生产力所需时间）
│   ├── MVP 交付时间
│   └── 开发工具链（IDE、调试器、性能分析器）
├── 生态适配
│   ├── 金融/交易类库
│   ├── 并发原语
│   └── 网络栈成熟度
└── 人才与长期发展
    ├── 招聘人才池规模
    ├── 大规模代码可维护性
    └── 社区活跃度
```

**备选方案**：
- **Rust**（搭配 Tokio 异步运行时）
- **Go**（搭配 goroutines + channels）
- **Java**（搭配 Virtual Threads / Loom + Vert.x）

**用户优先级约束**：延迟可预测性至关重要 —— 一次 GC 停顿发生在市场高峰期，可能意味着六位数的损失。

## Step 2: 多视角评估

### 视角 1：系统架构师

| 对比 | 性能 | 开发速度 | 生态适配 | 人才与长期发展 |
|----|-------------|-------------|---------------|-------------------|
| 性能 | 1 | 5 | 3 | 5 |
| 开发速度 | 1/5 | 1 | 1/2 | 1 |
| 生态适配 | 1/3 | 2 | 1 | 2 |
| 人才与长期发展 | 1/5 | 1 | 1/2 | 1 |

### 视角 2：工程经理

| 对比 | 性能 | 开发速度 | 生态适配 | 人才与长期发展 |
|----|-------------|-------------|---------------|-------------------|
| 性能 | 1 | 1 | 2 | 1 |
| 开发速度 | 1 | 1 | 2 | 2 |
| 生态适配 | 1/2 | 1/2 | 1 | 1 |
| 人才与长期发展 | 1 | 1/2 | 1 | 1 |

### 视角 3：量化开发者

| 对比 | 性能 | 开发速度 | 生态适配 | 人才与长期发展 |
|----|-------------|-------------|---------------|-------------------|
| 性能 | 1 | 3 | 2 | 7 |
| 开发速度 | 1/3 | 1 | 1 | 3 |
| 生态适配 | 1/2 | 1 | 1 | 3 |
| 人才与长期发展 | 1/7 | 1/3 | 1/3 | 1 |

## Step 3: 共识聚合

### 权重计算

| 准则 | 行几何均值 | 归一化权重 |
|-----------|-------------------|-------------------|
| 性能 | 1.82 | 0.42 |
| 开发速度 | 0.93 | 0.22 |
| 生态适配 | 1.01 | 0.23 |
| 人才与长期发展 | 0.56 | 0.13 |

**权重分布**（已应用延迟优先级约束）：
```
性能:           0.42 █████████████████████
生态适配:       0.23 ███████████
开发速度:       0.22 ███████████
人才与长期发展:  0.13 ██████
```

## Step 4: 一致性校验

**传递性验证**：
- 性能 > 生态适配 > 开发速度 > 人才与长期发展 ✓
- 性能 > 开发速度 ✓
- 性能 > 人才与长期发展 ✓
- 生态适配 ≈ 开发速度（0.23 vs 0.22，在容差范围内）✓
- 通过一致性检查 ✓

## Step 5: 方案评分

| 子准则 | 权重 | Rust | Go | Java |
|---------------|--------|------|-----|------|
| 原始吞吐量 | 0.15 | 10 | 8 | 8 |
| 延迟可预测性 | 0.17 | 10 | 7 | 5 |
| 内存效率 | 0.10 | 10 | 7 | 6 |
| 学习曲线 | 0.08 | 4 | 9 | 7 |
| MVP 交付时间 | 0.07 | 5 | 9 | 7 |
| 开发工具链 | 0.07 | 7 | 7 | 9 |
| 金融类库 | 0.09 | 5 | 6 | 9 |
| 并发原语 | 0.08 | 9 | 9 | 8 |
| 网络栈 | 0.06 | 8 | 8 | 9 |
| 招聘人才池 | 0.05 | 4 | 7 | 9 |
| 代码可维护性 | 0.04 | 9 | 7 | 7 |
| 社区活跃度 | 0.04 | 9 | 8 | 6 |

### 加权得分

| 方案 | 加权总分 |
|-------------|---------------------|
| **Rust** | **7.70** |
| **Go** | **7.55** |
| **Java** | **7.18** |

### 敏感性分析

场景 A —— 将"性能"权重从 0.42 降至 0.25（放宽延迟要求）：
- Go: 7.68 → **第 1**
- Rust: 7.15 → 第 2
- Java: 7.42 → 第 2

场景 B —— 将"开发速度"权重从 0.22 提升至 0.35（更紧的交付期限）：
- Go: 7.85 → **第 1**
- Rust: 7.05 → 第 3
- Java: 7.25 → 第 2

**核心发现**：Rust 仅在性能为主导关注点时胜出。在任何开发速度更重要的场景下，Go 都会领先。这是关键的权衡取舍。

## Step 6: 决策报告

# 决策报告：交易引擎语言选型

## 推荐方案
**Rust** — 综合得分：7.70 / 10

## 排名

| 排名 | 方案 | 得分 | 核心优势 |
|------|------------|-------|-------------|
| 1 | Rust | 7.70 | 零成本抽象、无 GC 停顿、确定性延迟、最佳内存安全 |
| 2 | Go | 7.55 | 开发速度最快、优秀的并发模型、最容易招人 |
| 3 | Java | 7.18 | 最丰富的金融生态、成熟的工具链，但 GC 停顿是实际隐患 |

## 关键权衡
- **Rust vs Go（关键的 0.15 分差距）**：Rust 保证零 GC 停顿 —— 对交易至关重要。但 Go 的开发速度优势意味着团队交付快 40-60%。如果延迟容忍度 >5ms P99，Go 是更好的选择
- **Java 的 GC 问题**：即使使用 ZGC/Shenandoah，Java 也无法在持续高负载下保证亚毫秒级 P99。金融类库生态无可匹敌，但延迟代价是真实存在的
- **Rust 的学习曲线**：预计团队需要 6-8 周才能达到生产力。借用检查器会带来挫败感，但它能在编译期捕获并发 bug，而这些 bug 在 Go/Java 中会成为生产事故

## 风险提示
- Rust 陡峭的学习曲线可能将 4 个月的时间线推延至 5-6 个月
- Rust 金融领域库有限，意味着需要更多自研代码
- 如果 Rust 招聘困难，考虑混合方案：Rust 用于热路径（撮合引擎），Go 用于其他模块（订单管理、风控、API 网关）

## 建议
1. 核心撮合引擎和订单簿采用 Rust
2. 外围服务（API 网关、风险管理、监控）采用 Go
3. 在启动重写前投入 3 周进行团队 Rust 集训
4. 尽早建立编码规范 —— Rust 的灵活性可能导致代码风格不一致
5. 从第一天起就配置持续基准测试（criterion.rs），及时发现性能回退
