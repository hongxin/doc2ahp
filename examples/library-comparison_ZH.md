# 示例：状态管理库对比

[English](library-comparison.md)

> 场景：React 项目需要引入全局状态管理，当前用 React Context + useReducer，随着应用复杂度增加需要更强大的方案。

## Step 1: 决策框架构建

**决策目标**：选择最适合中大型 React 应用的状态管理库

**评估层次**：

```
选择最佳状态管理库
├── 开发体验
│   ├── API 简洁度
│   ├── TypeScript 支持
│   └── DevTools 质量
├── 性能特性
│   ├── 渲染优化
│   └── 包体积
├── 生态与社区
│   ├── 社区活跃度
│   ├── 中间件/插件生态
│   └── 文档质量
└── 迁移成本
    ├── 与现有代码兼容性
    └── 渐进式采用能力
```

**备选方案**：
- **Zustand**
- **Jotai**
- **Redux Toolkit (RTK)**

## Step 2-3: 评估与聚合

综合前端架构师和一线开发者两个视角：

**共识权重**：

```
开发体验:   0.35 █████████████████
性能特性:   0.25 ████████████
生态与社区: 0.22 ███████████
迁移成本:   0.18 █████████
```

## Step 4: 一致性校验

- 开发体验 > 性能特性 > 生态与社区 > 迁移成本 ✓
- 所有传递关系一致 ✓

## Step 5: 方案评分

| 子准则 | 权重 | Zustand | Jotai | RTK |
|-------|------|---------|-------|-----|
| API 简洁度 | 0.14 | 9 | 8 | 6 |
| TypeScript 支持 | 0.11 | 8 | 9 | 8 |
| DevTools 质量 | 0.10 | 7 | 6 | 9 |
| 渲染优化 | 0.15 | 8 | 9 | 7 |
| 包体积 | 0.10 | 9 | 9 | 5 |
| 社区活跃度 | 0.08 | 8 | 7 | 9 |
| 中间件/插件生态 | 0.07 | 6 | 5 | 9 |
| 文档质量 | 0.07 | 7 | 7 | 8 |
| 与现有代码兼容性 | 0.09 | 8 | 7 | 6 |
| 渐进式采用能力 | 0.09 | 9 | 8 | 5 |

### 加权得分

| 方案 | 加权总分 |
|-----|---------|
| **Zustand** | **8.02** |
| **Jotai** | **7.65** |
| **RTK** | **6.92** |

### 敏感性分析

将"中间件/插件生态"权重提升至 0.15（假设项目需要大量中间件）：
- Zustand: 7.88
- RTK: 7.18（大幅上升）
- Jotai: 7.45

即使在生态权重大幅提升的情况下，Zustand 仍然领先。

## Step 6: 决策报告

# 决策报告：状态管理库选型

## 推荐方案
**Zustand** — 综合得分 8.02 / 10

## 排名

| 排名 | 方案 | 得分 | 核心优势 |
|-----|------|------|---------|
| 1 | Zustand | 8.02 | API 极简、包体积小、迁移成本低 |
| 2 | Jotai | 7.65 | 原子化模型、渲染优化最佳、TS 支持优秀 |
| 3 | RTK | 6.92 | 生态最完善、DevTools 最强、企业级验证 |

## 关键权衡
- Zustand vs Jotai：Zustand 更简单直接，Jotai 更适合细粒度状态管理
- Zustand vs RTK：Zustand 轻量灵活，RTK 规范完整但引入较多样板代码
- 若项目需要复杂的异步状态管理和时间旅行调试，RTK 的优势会更明显

## 风险提示
- Zustand 的中间件生态不如 RTK 丰富，复杂场景可能需要自行扩展
- Zustand 约定较少，团队需要自行建立状态管理规范

## 建议
1. 采用 Zustand 作为全局状态管理方案
2. 结合 React Query/TanStack Query 处理服务端状态
3. 建立团队内部的 store 组织规范（按功能域拆分 store）
4. 复杂表单状态考虑配合 React Hook Form 使用
