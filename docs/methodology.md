# Doc2AHP 方法论：从论文到软件决策实践

## 概述

本文档将 Doc2AHP 论文（Wu, Zhou, Zhang & Chen, 2026; [arXiv:2601.16479](https://arxiv.org/abs/2601.16479)）的学术方法映射到软件工程决策场景，为 Skill 实现提供方法论支撑。

## 1. 决策场景分类

### 1.1 技术选型决策

**场景**：选择编程语言、框架、数据库、云服务等
**特点**：备选方案明确，评估维度多元
**典型准则层次**：

```
选择最佳技术方案
├── 技术适配性
│   ├── 功能完整度
│   ├── 性能特性
│   └── 生态系统成熟度
├── 团队因素
│   ├── 学习曲线
│   ├── 现有技能匹配
│   └── 招聘市场
├── 工程质量
│   ├── 可维护性
│   ├── 测试支持
│   └── 文档质量
└── 商业因素
    ├── 许可证合规
    ├── 总拥有成本
    └── 供应商锁定风险
```

### 1.2 架构决策

**场景**：微服务 vs 单体、事件驱动 vs 请求响应、SQL vs NoSQL 等
**特点**：影响深远、难以逆转、需要多方权衡
**典型准则层次**：

```
选择最佳架构方案
├── 可扩展性
│   ├── 水平扩展能力
│   └── 数据分区策略
├── 可靠性
│   ├── 容错机制
│   └── 数据一致性
├── 开发效率
│   ├── 开发复杂度
│   ├── 部署复杂度
│   └── 调试难度
└── 运维成本
    ├── 基础设施成本
    └── 监控复杂度
```

### 1.3 库/工具对比

**场景**：React vs Vue、PostgreSQL vs MySQL、Jest vs Vitest 等
**特点**：备选方案功能相近，差异在细节
**典型准则层次**：

```
选择最佳库/工具
├── 功能匹配度
│   ├── 核心功能覆盖
│   └── 扩展能力
├── 开发体验
│   ├── API 设计
│   ├── 类型支持
│   └── 错误信息质量
├── 社区生态
│   ├── 社区活跃度
│   ├── 第三方插件
│   └── 长期维护信心
└── 集成成本
    ├── 迁移难度
    └── 与现有栈兼容性
```

## 2. 六步决策流程详解

### Step 1: 决策框架构建

**论文对应**：语义树构建（Semantic Tree Construction）

**操作流程**：

1. **明确决策目标**：用一句话描述要解决的决策问题
2. **提取准则**：从项目上下文、需求文档、团队讨论中提取评估维度
3. **构建层次**：将准则组织为 目标 → 主准则 → 子准则 → 备选方案
4. **认知约束检查**：
   - 每层准则数 ≤ 7（Miller's Law）
   - 层次深度 ≤ 3（含目标层）
   - 每个准则与目标的相关性自检

**准则提取启发式**：
- 从"用户会因为什么选择/放弃这个方案"入手
- 参考已有的 ADR（Architecture Decision Records）模板
- 考虑短期和长期影响

### Step 2: 多视角评估

**论文对应**：多 Agent 权重机制

**操作流程**：

1. **定义评估视角**（建议 3-5 个）：

| 视角 | 关注重点 |
|-----|---------|
| 技术专家 | 性能、架构适配、技术债务 |
| 业务分析师 | ROI、市场响应速度、商业价值 |
| 运维工程师 | 部署复杂度、监控、故障恢复 |
| 最终用户 | 体验流畅度、功能完整性 |
| 团队负责人 | 学习成本、团队生产力、招聘 |

2. **独立成对比较**：每个视角对主准则进行成对比较

成对比较模板（Saaty 1-9 标度）：

```
视角：技术专家
比较主准则相对重要性：

| vs | 技术适配性 | 团队因素 | 工程质量 | 商业因素 |
|----|-----------|---------|---------|---------|
| 技术适配性 | 1 | 3 | 2 | 5 |
| 团队因素 | 1/3 | 1 | 1/2 | 3 |
| 工程质量 | 1/2 | 2 | 1 | 4 |
| 商业因素 | 1/5 | 1/3 | 1/4 | 1 |
```

**Saaty 标度解读**：
- 1 = 同等重要
- 3 = 稍微重要（有轻微偏好）
- 5 = 明显重要（有强烈偏好）
- 7 = 非常重要（占据主导地位）
- 9 = 极端重要（压倒性优势）

### Step 3: 共识聚合

**论文对应**：加权几何均值 + Leader Agent

**操作流程**：

1. **几何均值聚合**：对每个成对比较值取多视角的几何均值

```
共识值 a_ij = (a_ij_视角1 × a_ij_视角2 × ... × a_ij_视角K)^(1/K)
```

2. **Leader 约束应用**：根据用户指定的优先级调整

例如用户说"性能优先"：
- 识别与性能相关的准则
- 在聚合后的矩阵中，适当提升该准则的相对权重
- 调整幅度：1-2个标度等级

3. **权重计算**（LLSM 简化版）：
- 每行元素取几何平均
- 归一化得到最终权重

### Step 4: 一致性校验

**论文对应**：自适应一致性优化

**操作流程**：

1. **传递性检查**：
   - 若 A 比 B 重要（a_AB > 1），且 B 比 C 重要（a_BC > 1）
   - 则 A 必须比 C 重要（a_AC > 1）
   - 违反此规则即为不一致

2. **不一致修正策略**：
   - 列出所有三元组，检查传递性
   - 对不一致的比较，重新评估并调整
   - 优先保留高置信度的比较，调整低置信度的

3. **简化一致性指标**：
   - 对于 LLM 执行的场景，不需要精确计算 CR
   - 通过传递性检查 + 合理性自检即可
   - 若发现明显矛盾，标记并修正

### Step 5: 方案评分

**论文对应**：效用评分

**操作流程**：

1. **逐准则评分**：对每个备选方案在每个子准则下打分（1-10）

```
| 子准则 | 权重 | 方案A | 方案B | 方案C |
|-------|------|------|------|------|
| 功能完整度 | 0.15 | 8 | 7 | 9 |
| 性能特性 | 0.12 | 9 | 6 | 7 |
| 学习曲线 | 0.10 | 5 | 8 | 6 |
| ... | ... | ... | ... | ... |
```

2. **加权汇总**：

```
方案得分 = Σ (准则权重 × 方案在该准则下的得分)
```

3. **敏感性分析**（可选）：
   - 调整关键准则权重 ±20%，观察排名是否变化
   - 若排名不变 → 结论稳健
   - 若排名变化 → 标记该准则为"决策关键因素"

### Step 6: 决策报告

**论文对应**：报告生成

**输出格式**：

```markdown
# 决策报告：[决策目标]

## 推荐方案
**[方案名]** — 综合得分 X.XX / 10

## 排名
| 排名 | 方案 | 得分 | 核心优势 |
|-----|------|------|---------|
| 1 | 方案A | 8.2 | ... |
| 2 | 方案B | 7.5 | ... |
| 3 | 方案C | 6.8 | ... |

## 准则权重分布
[列出各准则及其最终权重]

## 关键权衡
- 方案A 在 X 方面领先，但在 Y 方面落后于 方案B
- 若 Z 准则的权重提升 20%，排名将变为...

## 风险提示
[列出推荐方案的主要风险和缓解措施]

## 建议
[明确的行动建议，包括下一步行动]
```

## 3. 认知约束的理论基础

### Miller's Law（7±2 规则）

人类工作记忆容量约为 7±2 个信息块。因此：
- 每层准则数限制为 ≤ 7，确保决策者能同时考虑所有准则
- 备选方案数建议 ≤ 5，超过则先做初筛

### 论文的 K_max 和 D_max

- **K_max**（每层最大分支）：论文实验表明 5-7 为最佳范围
- **D_max**（最大深度）：3 层（目标-主准则-子准则）在绝大多数场景下足够

### 为什么不是越详细越好？

- 层次过深 → 权重被过度稀释，微小差异影响结果
- 准则过多 → 成对比较矩阵指数增长，一致性难以保证
- 过度分解 → 决策者认知过载，反而降低决策质量

## 4. 适用性边界

### 适合使用 Doc2AHP 的场景

- 有 3+ 个明确备选方案
- 评估维度 ≥ 3 且维度间有权衡关系
- 决策影响范围较大（架构级、技术栈级）
- 需要向团队/stakeholder 解释决策理由

### 不适合的场景

- 只有 2 个选项的简单对比 → 直接 pros/cons 分析即可
- 单一维度决策（如纯成本最优） → 直接比较即可
- 紧急决策 → 用直觉 + 快速验证
- 已有明确偏好只需验证 → 做 pros/cons 确认即可
